/**
 * Global state management using React Context
 * Manages vulnerability data, filters, and user preferences
 */

import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
} from "react";
import type {
  FlattenedVulnerability,
  FilterCriteria,
  VulnerabilityMetrics,
  UserPreferences,
  DataLoadingState,
  SortConfig,
  PaginationState,
} from "../types/vulnerability";
import { getDataLoader } from "../utils/dataLoader";
import { getAllVulnerabilities } from "../utils/indexedDB";
import { applyFilters, sortVulnerabilities } from "../utils/filtering";

interface VulnerabilityContextValue {
  // Data
  allVulnerabilities: FlattenedVulnerability[];
  filteredVulnerabilities: FlattenedVulnerability[];
  metrics: VulnerabilityMetrics | null;

  // Loading state
  loadingState: DataLoadingState;

  // Filters
  filters: FilterCriteria;
  setFilters: (filters: FilterCriteria) => void;
  updateFilter: <K extends keyof FilterCriteria>(
    key: K,
    value: FilterCriteria[K]
  ) => void;
  clearFilters: () => void;

  // Sorting
  sortConfig: SortConfig;
  setSortConfig: (config: SortConfig) => void;

  // Pagination
  pagination: PaginationState;
  setPagination: (pagination: Partial<PaginationState>) => void;

  // Preferences
  preferences: UserPreferences;
  updatePreferences: (prefs: Partial<UserPreferences>) => void;

  // Actions
  loadData: (url: string) => Promise<void>;
  refreshData: () => Promise<void>;

  // Comparison
  comparisonIds: string[];
  addToComparison: (id: string) => void;
  removeFromComparison: (id: string) => void;
  clearComparison: () => void;
}

const VulnerabilityContext = createContext<
  VulnerabilityContextValue | undefined
>(undefined);

const DEFAULT_PREFERENCES: UserPreferences = {
  theme: "light",
  pageSize: 50,
  defaultFilters: {},
  hiddenDashboardSections: [],
  favoriteVulnerabilities: [],
};

const DEFAULT_SORT: SortConfig = {
  field: "cvss",
  direction: "desc",
};

const DEFAULT_PAGINATION: PaginationState = {
  page: 0,
  pageSize: 50,
  total: 0,
};

const PREFERENCES_KEY = "svd-user-preferences";

export function VulnerabilityProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  // State
  const [allVulnerabilities, setAllVulnerabilities] = useState<
    FlattenedVulnerability[]
  >([]);
  const [filteredVulnerabilities, setFilteredVulnerabilities] = useState<
    FlattenedVulnerability[]
  >([]);
  const [metrics, setMetrics] = useState<VulnerabilityMetrics | null>(null);
  const [loadingState, setLoadingState] = useState<DataLoadingState>({
    status: "idle",
    progress: 0,
    message: "",
  });
  const [filters, setFiltersState] = useState<FilterCriteria>({});
  const [sortConfig, setSortConfig] = useState<SortConfig>(DEFAULT_SORT);
  const [pagination, setPaginationState] =
    useState<PaginationState>(DEFAULT_PAGINATION);
  const [comparisonIds, setComparisonIds] = useState<string[]>([]);

  // Load preferences from localStorage
  const [preferences, setPreferences] = useState<UserPreferences>(() => {
    try {
      const stored = localStorage.getItem(PREFERENCES_KEY);
      return stored
        ? { ...DEFAULT_PREFERENCES, ...JSON.parse(stored) }
        : DEFAULT_PREFERENCES;
    } catch {
      return DEFAULT_PREFERENCES;
    }
  });

  // Load vulnerabilities from IndexedDB
  const loadFromIndexedDB = useCallback(async () => {
    try {
      const vulns = await getAllVulnerabilities();
      setAllVulnerabilities(vulns);
      setFilteredVulnerabilities(vulns);
      setPaginationState((prev) => ({ ...prev, total: vulns.length }));
    } catch (error) {
      console.error("Failed to load from IndexedDB:", error);
    }
  }, []);

  // Save preferences to localStorage
  useEffect(() => {
    localStorage.setItem(PREFERENCES_KEY, JSON.stringify(preferences));
  }, [preferences]);

  // Initialize data loader
  useEffect(() => {
    const loader = getDataLoader();

    const unsubscribe = loader.onStateChange((state) => {
      setLoadingState(state);

      // Clear old data when loading starts
      if (state.status === "loading") {
        setAllVulnerabilities([]);
        setFilteredVulnerabilities([]);
        setMetrics(null);
      }

      // When data is ready, load from IndexedDB
      if (state.status === "ready") {
        loadFromIndexedDB();
        // Load fresh metrics
        loader.getCachedMetrics().then((cachedMetrics) => {
          if (cachedMetrics) {
            setMetrics(cachedMetrics);
          }
        });
      }
    });

    // Check if data already exists
    loader.isDataAvailable().then((available) => {
      if (available) {
        setLoadingState({
          status: "ready",
          progress: 100,
          message: "Data loaded from cache",
        });
        loadFromIndexedDB();
        loader.getCachedMetrics().then((cachedMetrics) => {
          if (cachedMetrics) {
            setMetrics(cachedMetrics);
          }
        });
      }
    });

    return () => {
      unsubscribe();
    };
  }, [loadFromIndexedDB]);

  // Apply filters and sorting whenever they change
  useEffect(() => {
    let result = applyFilters(allVulnerabilities, filters);
    result = sortVulnerabilities(result, sortConfig);
    setFilteredVulnerabilities(result);
    setPaginationState((prev) => ({ ...prev, total: result.length, page: 0 }));
  }, [allVulnerabilities, filters, sortConfig]);

  // Filter management
  const setFilters = useCallback((newFilters: FilterCriteria) => {
    setFiltersState(newFilters);
  }, []);

  const updateFilter = useCallback(
    <K extends keyof FilterCriteria>(key: K, value: FilterCriteria[K]) => {
      setFiltersState((prev) => ({ ...prev, [key]: value }));
    },
    []
  );

  const clearFilters = useCallback(() => {
    setFiltersState({});
  }, []);

  // Pagination management
  const setPagination = useCallback((update: Partial<PaginationState>) => {
    setPaginationState((prev) => ({ ...prev, ...update }));
  }, []);

  // Preferences management
  const updatePreferences = useCallback((prefs: Partial<UserPreferences>) => {
    setPreferences((prev) => ({ ...prev, ...prefs }));
  }, []);

  // Data loading
  const loadData = useCallback(async (url: string) => {
    const loader = getDataLoader();
    await loader.loadFromURL(url);
  }, []);

  const refreshData = useCallback(async () => {
    await loadFromIndexedDB();
  }, [loadFromIndexedDB]);

  // Comparison management
  const addToComparison = useCallback((id: string) => {
    setComparisonIds((prev) => {
      if (prev.includes(id)) return prev;
      if (prev.length >= 3) return prev; // Max 3 items
      return [...prev, id];
    });
  }, []);

  const removeFromComparison = useCallback((id: string) => {
    setComparisonIds((prev) => prev.filter((cid) => cid !== id));
  }, []);

  const clearComparison = useCallback(() => {
    setComparisonIds([]);
  }, []);

  const value: VulnerabilityContextValue = {
    allVulnerabilities,
    filteredVulnerabilities,
    metrics,
    loadingState,
    filters,
    setFilters,
    updateFilter,
    clearFilters,
    sortConfig,
    setSortConfig,
    pagination,
    setPagination,
    preferences,
    updatePreferences,
    loadData,
    refreshData,
    comparisonIds,
    addToComparison,
    removeFromComparison,
    clearComparison,
  };

  return (
    <VulnerabilityContext.Provider value={value}>
      {children}
    </VulnerabilityContext.Provider>
  );
}

/**
 * Hook to access vulnerability context
 */
export function useVulnerabilities() {
  const context = useContext(VulnerabilityContext);
  if (!context) {
    throw new Error(
      "useVulnerabilities must be used within VulnerabilityProvider"
    );
  }
  return context;
}

// Export provider for fast refresh compatibility
export { VulnerabilityProvider as Provider };
